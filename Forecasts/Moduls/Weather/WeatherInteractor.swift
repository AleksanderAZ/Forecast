//
//  WeatherInteractor.swift
//  Forecasts
//
//  Created Z on 11/5/19.
//  Copyright © 2019 Zyma. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit

class WeatherInteractor: WeatherInteractorProtocol {

    weak var presenter: WeatherPresenterProtocol?
    
    var dayWeather = [DayWeather]()
    var hourWeather = [HourWeather]()
    var currentCity: CityModel?
    
    func getDay(index: Int)->DayWeather? {
        if index < getDayCount() {
            return dayWeather[index]
        }
        else {
            return nil
        }
    }
    func getHour(index: Int)->HourWeather? {
        if index < getDayCount() {
            return hourWeather[index]
        }
        else {
            return nil
        }
    }
    
    func getDayCount()->Int {
        return dayWeather.count
    }
    
    func getCurrentCity()->CityModel? {
        return self.currentCity
    }
    
    private func update() {
        guard let presenter = self.presenter else { return }
        guard let _ = self.currentCity else { return }
        presenter.update()
    }
    
    func getForecasts(city: CityModel?) {
        guard let cityKey = city?.city.cityKey else {return}
        self.currentCity = city
        self.requestDayWeather(cityKey: cityKey)
    }
    
    private func requestDayWeather(cityKey: String) {
        let pathURL = RequestsDataAPI.forecastDayPath + cityKey
        NetworkServiceAPI.shared.loadAPIRequest(pathURL: pathURL) { [weak self] (result: ForecastDayAPIJSONModel?, error) in
            guard let self = self else { return }
            guard let result = result else { print(String(describing: error)); return }
            self.setDayWeather(result: result)
            self.requestHourWeather(cityKey: cityKey)
        }
    }
    
    private func requestHourWeather(cityKey: String) {
        let pathURL = RequestsDataAPI.forecastHoursPath + cityKey
        NetworkServiceAPI.shared.loadAPIRequest(pathURL: pathURL) { [weak self] (result: [ForecastHourAPIJSONModel]?, error) in
            guard let self = self else { return }
            guard let result = result else { print(String(describing: error)); return }
            self.setHourWeather(result: result)
            self.update()
        }
    }
    
    private func setDayWeather(result: ForecastDayAPIJSONModel?) {
        var  dayWeather = [DayWeather]()
        guard let dailyForecasts = result?.dailyForecasts else { return}
        for item in dailyForecasts {
            guard let day = item.date else {return}
            guard let icon = item.day?.cloudCover else {return}
            guard let tempMax = item.temperature?.maximum?.value else {return}
            guard let tempMin = item.temperature?.minimum?.value else {return}
            let temp = "\((tempMin+tempMax)/2)"
            guard let sunRise = item.sun?.rise else {return}
            guard let sunSet = item.sun?.sunSet else {return}
            let oneDay = DayWeather(day: day, icon: "\(icon)", temp: temp, sunRise: sunRise, sunSet: sunSet)
            dayWeather.append(oneDay)
        }
        self.dayWeather = dayWeather
    }
    
    private func setHourWeather(result: [ForecastHourAPIJSONModel]?) {
        var  hourWeather = [HourWeather]()
        guard let forecastHour = result else { return}
        for item in forecastHour {
            guard let hour = item.dateTime else {return}
            guard let icon = item.iconPhrase else { return}
            guard let temp = item.temperature?.value else {return}
            let oneHour =  HourWeather(hour: hour, icon: icon, temp: "\(temp)")
            hourWeather.append(oneHour)
        }
        self.hourWeather = hourWeather
    }
    
    func getHourCount()->Int {
        return hourWeather.count
    }
}
