//
//  CityInteractor.swift
//  Forecasts
//
//  Created Z on 11/5/19.
//  Copyright © 2019 Zyma. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit

class CityInteractor: CityInteractorProtocol {

    weak var presenter: CityPresenterProtocol?
    var citysData = CitysData()
    var citys = [CityModel]()
    
    private func request(index: Int) {
        guard index < citys.count else { return }
        let citySearch = citys[index].city
        let pathURL = RequestsDataAPI.currentWeatherPath + citySearch.cityKey
        NetworkServiceAPI.shared.loadAPIRequest(pathURL: pathURL) { [weak self] (result: [CurrentlyAPIJSONModel]?, error) in
            guard let self = self else { return }
            guard let result = result else { print(error as Any); return }
            var cityTempr: String
            var cityLink: String
            if let tempr = result.first?.temperature?.metric?.value {
                 cityTempr = "\(tempr)"
            }
            else {
                cityTempr = "?"
            }
            if let link = result.first?.mobileLink {
                cityLink = link
            }
            else {
                cityLink = RequestsDataAPI.webURL
            }
            self.citys[index].tempr = cityTempr
            self.citys[index].link = cityLink
        }
    }
    private func updateTempr(index: Int) {
        let quantity = citys.count

        if (index < quantity) {
            self.request(index: index)
            self.updateTempr(index: index + 1)
        }
        else {
            presenter?.update()
        }
    }
    
    func refreshTempr() {
        self.updateTempr(index: 0)
    }
    
    func addCity(citySearch: CitySearchModel?) {
        guard let citySearch = citySearch else { return }
        var isExist = false
        for city in self.citys {
            if (city.city.cityKey == citySearch.cityKey) {
                isExist = true
                break
            }
        }
        if (isExist == false) {
            self.citys.append(CityModel(city: citySearch, tempr: "", link: ""))
            self.request(index: self.citys.count - 1)
            presenter?.update()
        }
    }
    
    func deleteCity(index: Int) {
        self.citys.remove(at: index)
    }
    
    func loadCitys() {
        let cityDef = citysData.getUserDef()
        if cityDef.count > 0 {
            for item in cityDef {
                self.addCity(citySearch: item)
            }
        }
        else {
            presenter?.showSearchCityView()
        }
    }
    
    func saveCitys() {
        citysData.saveUserDef(save: citys)
    }
    
    func countCity()->Int {
        return citys.count
    }
    
    func getCity(index: Int)->CityModel? {
        guard  index < citys.count else { return nil }
        return citys[index]
    }
}
